Functional May Not Be the Right Word for Haskell
================================================

*1 Aug 2016*
------------

Haskell is a functional programming language.
Nobody can claim it isn't.
It uses functions to do things, avoids affecting global mutable state, and generally embodies everything about functional programming.

Except, it also embodies so much more.

Static typing isn't required for functional programming; most common functional languages aren't static.
Heck, a lot don't have pervasive type systems.
All Lisp dialects, as well as Erlang, lack this feature.
So Haskell is something more than just a functional language.

Think about it like this: Java is an object-oriented language.
I don't think there is a doubt in anyone's mind that Java is object-oriented.
Describing it as procedural seems wrong in some way.
But at the core, Java code looks a heckuva lot like C++ code.
And C++, while being many things, is procedural.
So while Java often looks like code that could be called procedural, it is something else.
That's what I'm trying to say about Haskell.

Haskell is more about types than anything else.
The reason to use Haskell, beyond curiosity, is that its type system is very powerful.
Haskell's type system is one of the most strict type systems you will find, but is also incredibly robust.
Haskell showcases what can be done with type systems.

What I'm trying to say is that Haskell seems more like a type-oriented language than a funcitonal one.
If you just wanted to pick up a functional language, after all, Clojure is a lot easier to learn.
